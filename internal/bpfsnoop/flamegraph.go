// Copyright 2025 Leon Hwang.
// SPDX-License-Identifier: Apache-2.0

// Generated by GitHub Copilot with Claude 3.7 Sonnet Thinking model.

package bpfsnoop

import (
	"fmt"
	"os"
	"strings"
)

// StackFrame represents a function call in the profile
type StackFrame struct {
	Name     string
	Value    int
	Children []*StackFrame
}

// FlameGraph stores the hierarchical profile data
type FlameGraph struct {
	RootFrame  *StackFrame
	TotalValue int
}

// NewFlameGraph creates a new flamegraph with default settings
func NewFlameGraph() *FlameGraph {
	return &FlameGraph{
		RootFrame: &StackFrame{Name: "root", Value: 0, Children: []*StackFrame{}},
	}
}

// AddStack adds a single stack trace to the flame graph
// stack should be ordered from root to leaf (bottom to top of call stack)
func (fg *FlameGraph) AddStack(stack []string, value int) {
	if len(stack) == 0 {
		return
	}

	fg.TotalValue += value
	current := fg.RootFrame
	current.Value += value

	for _, frame := range stack {
		found := false
		for _, child := range current.Children {
			if child.Name == frame {
				child.Value += value
				current = child
				found = true
				break
			}
		}

		if !found {
			newFrame := &StackFrame{
				Name:     frame,
				Value:    value,
				Children: []*StackFrame{},
			}
			current.Children = append(current.Children, newFrame)
			current = newFrame
		}
	}
}

// generateFoldedStacks converts the tree structure to folded stack format
// compatible with Brendan Gregg's flamegraph.pl
func (fg *FlameGraph) generateFoldedStacks() []string {
	var foldedStacks []string

	var traverse func(frame *StackFrame, path []string)
	traverse = func(frame *StackFrame, path []string) {
		// Skip the root frame in the output
		var currentPath []string
		if frame.Name != "root" {
			// Build path with this frame
			currentPath = append(path, frame.Name)

			// Calculate self value (value not attributed to children)
			selfValue := frame.Value
			for _, child := range frame.Children {
				selfValue -= child.Value
			}

			// If this frame has any samples itself (not just passed to children)
			if selfValue > 0 {
				// Create the folded format: func1;func2;func3 42
				line := fmt.Sprintf("%s %d", strings.Join(currentPath, ";"), selfValue)
				foldedStacks = append(foldedStacks, line)
			}
		} else {
			// For root, just pass on the existing path
			currentPath = path
		}

		// Recursively process all children with current path
		for _, child := range frame.Children {
			traverse(child, currentPath)
		}
	}

	// Start traversal with empty path
	traverse(fg.RootFrame, []string{})
	return foldedStacks
}

// Save writes the folded stack data to the specified file
func (fg *FlameGraph) Save(filename string) error {
	if len(fg.RootFrame.Children) == 0 {
		return nil
	}

	// Generate folded stacks
	foldedStacks := fg.generateFoldedStacks()
	if len(foldedStacks) == 0 {
		return nil
	}

	// Open file for writing
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o644)
	if err != nil {
		return err
	}
	defer f.Close()

	// Write folded stacks to file
	content := strings.Join(foldedStacks, "\n") + "\n"
	_, err = f.WriteString(content)
	return err
}
